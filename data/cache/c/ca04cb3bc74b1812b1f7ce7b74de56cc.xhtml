
<h1 class="sectionedit1" id="saturday_may_7th_2022">Saturday, May 7th, 2022</h1>
<div class="level1">

<p>
<span class="wrap_lo ">“A language that doesn’t affect the way you think about programming, is not worth knowing.”
Alan Perlis“</span>
</p>

<p>
<br/>

<br/>

</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Saturday, May 7th, 2022&quot;,&quot;hid&quot;:&quot;saturday_may_7th_2022&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:1,&quot;range&quot;:&quot;1-173&quot;} -->
<h3 class="sectionedit2" id="things_that_didn_t_happen_on_the_today">Things that didn&#039;t happen on the today</h3>
<div class="level3">

</div>

<h4 id="not_much">not much</h4>
<div class="level4">

<p>
<sup><a href="#fn__1" id="fnt__1" class="fn_top">1)</a></sup>
</p>

<p>
Not much happened last week. Lots of work work I guess. I finished the snake tutorial. Still don&#039;t get it. 
</p>

<p>
I found this APP called <a href="https://github.com/rust-lang/rustlings" class="urlextern" title="https://github.com/rust-lang/rustlings" rel="ugc nofollow"> rustlings</a>. Its a bunch of small exercises that help teach the language. Going through those over the weekend should hopefully help.
</p>

</div>

<h4 id="ink_shit">Ink Shit</h4>
<div class="level4">

<p>
I made these small sketches <br/>

</p>

<p>
<a href="/Projects/ultraletterlinker/lib/exe/fetch.php?media=devlogs:ullbreakdown.jpg" class="media" title="devlogs:ullbreakdown.jpg"><img src="/Projects/ultraletterlinker/lib/exe/fetch.php?w=600&amp;tok=1b7d35&amp;media=devlogs:ullbreakdown.jpg" class="mediacenter" alt="" width="600" /></a>
</p>

<p>
The top half is super letter linker and the bottom is super text twist. They both have some similar parts. I think that super text twist could be a good proof of concept and then I can turn it into letter linker by adding the “Linking” and level generation shtuff.
</p>

<p>
<a href="/Projects/ultraletterlinker/lib/exe/fetch.php?media=devlogs:ull_ecs-e-fication.jpg" class="media" title="devlogs:ull_ecs-e-fication.jpg"><img src="/Projects/ultraletterlinker/lib/exe/fetch.php?w=600&amp;tok=7e0adf&amp;media=devlogs:ull_ecs-e-fication.jpg" class="mediacenter" alt="" width="600" /></a>
</p>

<p>
I tried to ecs-ify super letter linker. but you know. <sup><a href="#fn__2" id="fnt__2" class="fn_top">2)</a></sup> <sup><a href="#fn__3" id="fnt__3" class="fn_top">3)</a></sup>
</p>

</div>

<h4 id="ohyeaandididthis">ohyeaandididthis</h4>
<div class="level4">

<p>
Oh yea and I set up <a href="https://github.com/neovide/neovide" class="urlextern" title="https://github.com/neovide/neovide" rel="ugc nofollow"> Neo vide</a> why?? cause it looks cool.. 
</p>

<p>
<a href="/Projects/ultraletterlinker/lib/exe/fetch.php?media=devlogs:nvide.png" class="media" title="devlogs:nvide.png"><img src="/Projects/ultraletterlinker/lib/exe/fetch.php?w=400&amp;tok=9d768a&amp;media=devlogs:nvide.png" class="media" alt="" width="400" /></a> <sup><a href="#fn__4" id="fnt__4" class="fn_top">4)</a></sup>
<br/>

</p>

<p>
I also setup a new path folder on my E: drive and then added a bash command to startup nvide.exe
</p>

<p>
At some point it would be cool to add it to my right click context menu to open up neovide at a given location.
</p>
<!-- EDIT{&quot;target&quot;:&quot;plugin_wrap_start&quot;,&quot;secid&quot;:3,&quot;range&quot;:&quot;0-&quot;} --><div class="wrap_left wrap_alert plugin_wrap" style="width: 60%;">
<p>
 My coolness factor went up around 20%
</p>
</div><!-- EDIT{&quot;target&quot;:&quot;plugin_wrap_end&quot;,&quot;secid&quot;:4,&quot;range&quot;:&quot;0-&quot;} -->
</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Things that didn&#039;t happen on the today&quot;,&quot;hid&quot;:&quot;things_that_didn_t_happen_on_the_today&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:2,&quot;range&quot;:&quot;174-1629&quot;} -->
<h3 class="sectionedit5" id="lol">lol</h3>
<div class="level3">

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;lol&quot;,&quot;hid&quot;:&quot;lol&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:5,&quot;range&quot;:&quot;1630-1644&quot;} -->
<h3 class="sectionedit6" id="today_todaaayz_stuff">Today Todaaayz stuff</h3>
<div class="level3">

</div>

<h4 id="ownership">Ownership</h4>
<div class="level4">

<p>
<em class="u">Ownership in rust is the set of rules on how memory is managed</em>
</p>

<p>
ownership also makes rust safe. Take a look at this insane chart
<br/>

<a href="https://medium.com/learning-rust/rust-basics-e73304ab35c7" class="media" title="https://medium.com/learning-rust/rust-basics-e73304ab35c7" rel="ugc nofollow"><img src="/Projects/ultraletterlinker/lib/exe/fetch.php?w=256&amp;tok=ece663&amp;media=devlogs:rust_is_safe_lol.png" class="media" alt="" width="256" /></a>
</p>

<p>
basically Instead of having a garbage collector which will effect performance, or needing to keep track of memory yourself <sup><a href="#fn__5" id="fnt__5" class="fn_top">5)</a></sup>. Rust has some basic rules around borrowing that are checked during compile time. It inserts its own clean up code during compile time. This works because it is so fucking anal about everything jesus. 
</p>

</div>

<h5 id="stack_and_heap">Stack and Heap</h5>
<div class="level5">

<p>
<a href="https://www.stechies.com/difference-between-stack-heap" class="media" title="https://www.stechies.com/difference-between-stack-heap" rel="ugc nofollow"><img src="/Projects/ultraletterlinker/lib/exe/fetch.php?w=256&amp;tok=a87d6b&amp;media=devlogs:stack_v_heap.jpg" class="media" title="stack_v_heap.jpg" alt="stack_v_heap.jpg" width="256" /></a> <sup><a href="#fn__6" id="fnt__6" class="fn_top">6)</a></sup>
</p>

<p>
<strong>Stack:</strong>
The stack stores values in a linear way. It puts the data in the order it receives it and removes them in the opposite order. This is knows as last in first out<sup><a href="#fn__7" id="fnt__7" class="fn_top">7)</a></sup>
</p>
<blockquote  class="blockquote-plugin">
<p>
<br/>

<br/>

Think of a stack of plates: when you add more plates, you put them on top of the pile, and when you need a plate, you take one off the top. Adding or removing plates from the middle or bottom wouldn’t work as well! Adding data is called pushing onto the stack, and removing data is called popping off the stack 
</p>

<p>
<cite class="blockquote-plugin"> The wonderful people at the <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" class="urlextern" title="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" rel="ugc nofollow"> RustDocs</a></cite>
</p>

</blockquote>
<p>
<br/>

</p>

<p>
All data on the stack <strong>MUST</strong> have a knows fixed size at compile time
</p>

<p>
<strong>Heap:</strong>
The heap is less organized. You request space. The memory allocator finds you some thats big enough and gives you a pointer to it <sup><a href="#fn__8" id="fnt__8" class="fn_top">8)</a></sup>. Since the pointer is always of a fixed size, you can store that in the stack.
</p>
<blockquote  class="blockquote-plugin">
<p>
<br/>

<br/>

Think of being seated at a restaurant. When you enter, you state the number of people in your group, and the staff finds an empty table that fits everyone and leads you there. If someone in your group comes late, they can ask where you’ve been seated to find you.
</p>

<p>
<cite class="blockquote-plugin"> the wonderful wonderful people at the <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" class="urlextern" title="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" rel="ugc nofollow"> RustDocs</a></cite>
</p>

</blockquote>
<p>
Pushing to the stack is faster ↔ allocating to the heap is slower because it has to find memory rather than just <em>popping</em> it on top
</p>

<p>
Reading values from the stack is faster, the computer knows how much to jump to the next memory location ↔ Reading form the heap is slower as the computer<sup><a href="#fn__9" id="fnt__9" class="fn_top">9)</a></sup> has to take the pointer and find it in the heap.
</p>

<p>
The computer would rather work on data on the stack as it is so much faster and cooler. 
</p>
<blockquote  class="blockquote-plugin">
<p>
<br/>

<br/>

When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function’s local variables get pushed onto the stack. When the function is over, those values get popped off the stack.
<cite class="blockquote-plugin">umm if you don&#039;t know… now you know the wonderful wonderful people at the <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" class="urlextern" title="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" rel="ugc nofollow"> RustDocs</a></cite>
</p>

</blockquote>
<p>
<br/>

<br/>

</p>

</div>

<h5 id="ownership_rules">Ownership Rules</h5>
<div class="level5">
<ol>
<li class="level1"><div class="li"> Each value in Rust has a variable that is called its <strong>OWNER</strong></div>
</li>
<li class="level1"><div class="li"> There can be only one <strong>OWNER</strong> at a time</div>
</li>
<li class="level1"><div class="li"> When the <strong>OWNER</strong> goes out of scope, the variable is dropped</div>
</li>
</ol>

</div>

<h5 id="variable_scope">Variable Scope</h5>
<div class="level5">

<p>
simple shit
</p>
<pre class="code rust"><span class="br0">&#123;</span> <span class="co0">// s is not valid here or before</span>
   <span class="kw1">let</span> s <span class="sy0">=</span> <span class="st0">&quot;yolo&quot;</span><span class="sy0">;</span> <span class="co0">//s is not valid</span>
   <span class="co0">//wow s your so cool cause we can use you for things here!</span>
<span class="br0">&#125;</span> <span class="co0">//s has been dropped</span></pre>

<p>
see, simple. 
</p>

</div>

<h5 id="freeing_memeory">freeing memeory</h5>
<div class="level5">

<p>
When we request memory and are done with it. We must free it. Every allocate should be paired with one free of the memory.
</p>

<p>
Garbage collected languages scan for unused memory periodically and free it.
Big boi languages expect you to do it yourself. 
</p>

<p>
<strong>RUST DROPS THAT SHIT WHEN IT GOES OUT OF SCOPE</strong>
</p>

</div>

<h5 id="move">Move</h5>
<div class="level5">

<p>
With simple types that are stored on the stack. A copy of the data is made when we try to bind it to another variable. <strong>This is a deep copy</strong>
</p>
<pre class="code rust"><span class="kw1">let</span> x <span class="sy0">=</span><span class="nu0">2</span><span class="sy0">;</span>
<span class="kw1">let</span> y<span class="sy0">=</span>x<span class="sy0">;</span>
println<span class="sy0">!</span><span class="br0">&#40;</span><span class="st0">&quot;{}&quot;</span><span class="sy0">,</span>y<span class="br0">&#41;</span><span class="sy0">;</span>
println<span class="sy0">!</span><span class="br0">&#40;</span><span class="st0">&quot;{}&quot;</span><span class="sy0">,</span>x<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
that will compile.
</p>

<p>
However with data stored on the Heap such as a string it would be to time consuming and expensive to run. So rust would just store the pointer to the data in the new variable. 
<br/>

<a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" class="media" title="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" rel="ugc nofollow"><img src="/Projects/ultraletterlinker/lib/exe/fetch.php?w=200&amp;tok=bd1a03&amp;media=devlogs:string_copy.png" class="media" alt="" width="200" /></a>
</p>

<p>
But what if s1 goes out of scope first and the data gets dropped?????????? so when we do something like this rust will just “move” the refrence from s1 to s2 and s1 will go out of scope.
</p>
<pre class="code rust"><span class="kw1">let</span> s1 <span class="sy0">=</span> String<span class="sy0">::</span><span class="me1">from</span><span class="br0">&#40;</span><span class="st0">&quot;Shaun&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">let</span> s2 <span class="sy0">=</span> s1<span class="sy0">;</span> <span class="co0">// s1 has gone out of scope</span>
println<span class="sy0">!</span><span class="br0">&#40;</span><span class="st0">&quot;{} PauL&quot;</span><span class="sy0">,</span>s2<span class="br0">&#41;</span><span class="sy0">;</span>
println<span class="sy0">!</span><span class="br0">&#40;</span><span class="st0">&quot;{} FaiL&quot;</span><span class="sy0">,</span>s1<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
That will not compile.
</p>

<p>
<a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" class="media" title="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" rel="ugc nofollow"><img src="/Projects/ultraletterlinker/lib/exe/fetch.php?w=200&amp;tok=e185cc&amp;media=devlogs:string_move.png" class="media" alt="" width="200" /></a>
</p>

<p>
by default none of rust&#039;s functions will <strong>deep copy</strong> any heap data so you can just assume that it <strong>moves</strong> it.
</p>

</div>

<h5 id="clone">Clone</h5>
<div class="level5">

<p>
If you did wanna <strong>deep copy</strong> heap data. You can clone it. Strings derive clone.
</p>
<pre class="code rust">    <span class="kw1">let</span> s1 <span class="sy0">=</span> String<span class="sy0">::</span><span class="me1">from</span><span class="br0">&#40;</span><span class="st0">&quot;hello&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw1">let</span> s2 <span class="sy0">=</span> s1.clone<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    println<span class="sy0">!</span><span class="br0">&#40;</span><span class="st0">&quot;s1 = {}, s2 = {}&quot;</span><span class="sy0">,</span> s1<span class="sy0">,</span> s2<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co0">//Good job it compiles and you wasted memory!</span>
    <span class="co0">//Copied from the rust book</span></pre>

</div>

<h5 id="copy">Copy</h5>
<div class="level5">

<p>
As with the simple int example above. Simple stack stored traits can be copied and used over again. Even structs that contain these copyable types can be copied. If a type inherits the <strong>drop</strong> trait it cannot be copied.
</p>

<p>
<span class="wrap_lo "> things that can be copied : u32,bool,f64,char, moreplscheckthedocs. </span>
</p>

<p>
an (i32,i32) can be copied but a (i32,string) cannot.
</p>

</div>

<h5 id="ownership_and_functions">Ownership and Functions</h5>
<div class="level5">

<p>
its simple
</p>
<pre class="code rust"><span class="kw1">fn</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">let</span> s <span class="sy0">=</span> String<span class="sy0">::</span><span class="me1">from</span><span class="br0">&#40;</span><span class="st0">&quot;hello&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>  <span class="co0">// s comes into scope</span>
&nbsp;
    takes_ownership<span class="br0">&#40;</span>s<span class="br0">&#41;</span><span class="sy0">;</span>             <span class="co0">// s's value moves into the function...</span>
                                    <span class="co0">// ... and so is no longer valid here</span>
&nbsp;
    <span class="kw1">let</span> x <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>                      <span class="co0">// x comes into scope</span>
&nbsp;
    makes_copy<span class="br0">&#40;</span>x<span class="br0">&#41;</span><span class="sy0">;</span>                  <span class="co0">// x would move into the function,</span>
                                    <span class="co0">// but i32 is Copy, so it's okay to still</span>
                                    <span class="co0">// use x afterward</span>
&nbsp;
<span class="br0">&#125;</span> <span class="co0">// Here, x goes out of scope, then s. But because s's value was moved, nothing</span>
  <span class="co0">// special happens.</span>
&nbsp;
<span class="kw1">fn</span> takes_ownership<span class="br0">&#40;</span>some_string<span class="sy0">:</span> String<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="co0">// some_string comes into scope</span>
    println<span class="sy0">!</span><span class="br0">&#40;</span><span class="st0">&quot;{}&quot;</span><span class="sy0">,</span> some_string<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span> <span class="co0">// Here, some_string goes out of scope and `drop` is called. The backing</span>
  <span class="co0">// memory is freed.</span>
&nbsp;
<span class="kw1">fn</span> makes_copy<span class="br0">&#40;</span>some_integer<span class="sy0">:</span> <span class="kw3">i32</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="co0">// some_integer comes into scope</span>
    println<span class="sy0">!</span><span class="br0">&#40;</span><span class="st0">&quot;{}&quot;</span><span class="sy0">,</span> some_integer<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span> <span class="co0">// Here, some_integer goes out of scope. Nothing special happens.</span>
&nbsp;
<span class="co0">//Copied from the rust book</span></pre>

<p>
Things that derive copy, get copied into a function. and droppable types get moved.
Returning stuff follows a similar rule.
</p>
<pre class="code rust"><span class="kw1">fn</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">let</span> s1 <span class="sy0">=</span> gives_ownership<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>         <span class="co0">// gives_ownership moves its return</span>
                                        <span class="co0">// value into s1</span>
&nbsp;
    <span class="kw1">let</span> s2 <span class="sy0">=</span> String<span class="sy0">::</span><span class="me1">from</span><span class="br0">&#40;</span><span class="st0">&quot;hello&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>     <span class="co0">// s2 comes into scope</span>
&nbsp;
    <span class="kw1">let</span> s3 <span class="sy0">=</span> takes_and_gives_back<span class="br0">&#40;</span>s2<span class="br0">&#41;</span><span class="sy0">;</span>  <span class="co0">// s2 is moved into</span>
                                        <span class="co0">// takes_and_gives_back, which also</span>
                                        <span class="co0">// moves its return value into s3</span>
<span class="br0">&#125;</span> <span class="co0">// Here, s3 goes out of scope and is dropped. s2 was moved, so nothing</span>
  <span class="co0">// happens. s1 goes out of scope and is dropped.</span>
&nbsp;
<span class="kw1">fn</span> gives_ownership<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">-&gt;</span> String <span class="br0">&#123;</span>             <span class="co0">// gives_ownership will move its</span>
                                             <span class="co0">// return value into the function</span>
                                             <span class="co0">// that calls it</span>
&nbsp;
    <span class="kw1">let</span> some_string <span class="sy0">=</span> String<span class="sy0">::</span><span class="me1">from</span><span class="br0">&#40;</span><span class="st0">&quot;yours&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="co0">// some_string comes into scope</span>
&nbsp;
    some_string                              <span class="co0">// some_string is returned and</span>
                                             <span class="co0">// moves out to the calling</span>
                                             <span class="co0">// function</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="co0">// This function takes a String and returns one</span>
<span class="kw1">fn</span> takes_and_gives_back<span class="br0">&#40;</span>a_string<span class="sy0">:</span> String<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> String <span class="br0">&#123;</span> <span class="co0">// a_string comes into</span>
                                                      <span class="co0">// scope</span>
&nbsp;
    a_string  <span class="co0">// a_string is returned and moves out to the calling function</span>
<span class="br0">&#125;</span>
<span class="co0">//Taken from the rust docs.. Again please read that. and not this...</span></pre>

<p>
S1 gets ownership from the functions return.
</p>

<p>
S2 is moved into the function and then is returend back to s3 
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Today Todaaayz stuff&quot;,&quot;hid&quot;:&quot;today_todaaayz_stuff&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:6,&quot;range&quot;:&quot;1645-&quot;} --><div class="footnotes">
<div class="fn"><sup><a href="#fnt__1" id="fn__1" class="fn_bot">1)</a></sup> 
<div class="content">yea I said it like that, so what?</div></div>
<div class="fn"><sup><a href="#fnt__2" id="fn__2" class="fn_bot">2)</a></sup> 
<div class="content">eh</div></div>
<div class="fn"><sup><a href="#fnt__3" id="fn__3" class="fn_bot">3)</a></sup> 
<div class="content">ehhhhhh</div></div>
<div class="fn"><sup><a href="#fnt__4" id="fn__4" class="fn_bot">4)</a></sup> 
<div class="content">Yea babyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy</div></div>
<div class="fn"><sup><a href="#fnt__5" id="fn__5" class="fn_bot">5)</a></sup> 
<div class="content">like a savage</div></div>
<div class="fn"><sup><a href="#fnt__6" id="fn__6" class="fn_bot">6)</a></sup> 
<div class="content">I dooly say these images take you to the websites frometh which I sto-el them</div></div>
<div class="fn"><sup><a href="#fnt__7" id="fn__7" class="fn_bot">7)</a></sup> 
<div class="content">and not lastin of us 2</div></div>
<div class="fn"><sup><a href="#fnt__8" id="fn__8" class="fn_bot">8)</a></sup> 
<div class="content">allocating memory</div></div>
<div class="fn"><sup><a href="#fnt__9" id="fn__9" class="fn_bot">9)</a></sup> 
<div class="content">NOT <a href="https://en.wikipedia.org/wiki/Joseph_Schumpeter" class="urlextern" title="https://en.wikipedia.org/wiki/Joseph_Schumpeter" rel="ugc nofollow"> Schumpeter</a></div></div>
</div>
